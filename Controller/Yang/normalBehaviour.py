
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
class yc_feature_normalBehaviour__features_feature(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module normalBehaviour - based on the path /features/feature. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__name','__mean','__standardDeviation',)

  _yang_name = 'feature'
  _rest_name = 'feature'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__standardDeviation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="standardDeviation", rest_name="standardDeviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)
    self.__mean = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="mean", rest_name="mean", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'features', u'feature']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'features', u'feature']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /features/feature/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /features/feature/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)


  def _get_mean(self):
    """
    Getter method for mean, mapped from YANG variable /features/feature/mean (decimal64)
    """
    return self.__mean
      
  def _set_mean(self, v, load=False):
    """
    Setter method for mean, mapped from YANG variable /features/feature/mean (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mean is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mean() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="mean", rest_name="mean", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mean must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="mean", rest_name="mean", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)""",
        })

    self.__mean = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mean(self):
    self.__mean = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="mean", rest_name="mean", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)


  def _get_standardDeviation(self):
    """
    Getter method for standardDeviation, mapped from YANG variable /features/feature/standardDeviation (decimal64)
    """
    return self.__standardDeviation
      
  def _set_standardDeviation(self, v, load=False):
    """
    Setter method for standardDeviation, mapped from YANG variable /features/feature/standardDeviation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_standardDeviation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_standardDeviation() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="standardDeviation", rest_name="standardDeviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """standardDeviation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="standardDeviation", rest_name="standardDeviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)""",
        })

    self.__standardDeviation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_standardDeviation(self):
    self.__standardDeviation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="standardDeviation", rest_name="standardDeviation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  mean = __builtin__.property(_get_mean, _set_mean)
  standardDeviation = __builtin__.property(_get_standardDeviation, _set_standardDeviation)


  _pyangbind_elements = {'name': name, 'mean': mean, 'standardDeviation': standardDeviation, }


class yc_features_normalBehaviour__features(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module normalBehaviour - based on the path /features. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__feature',)

  _yang_name = 'features'
  _rest_name = 'features'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__feature = YANGDynClass(base=YANGListType("name",yc_feature_normalBehaviour__features_feature, yang_name="feature", rest_name="feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="feature", rest_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'features']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'features']

  def _get_feature(self):
    """
    Getter method for feature, mapped from YANG variable /features/feature (list)
    """
    return self.__feature
      
  def _set_feature(self, v, load=False):
    """
    Setter method for feature, mapped from YANG variable /features/feature (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_feature_normalBehaviour__features_feature, yang_name="feature", rest_name="feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="feature", rest_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_feature_normalBehaviour__features_feature, yang_name="feature", rest_name="feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="feature", rest_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)""",
        })

    self.__feature = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature(self):
    self.__feature = YANGDynClass(base=YANGListType("name",yc_feature_normalBehaviour__features_feature, yang_name="feature", rest_name="feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="feature", rest_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)

  feature = __builtin__.property(_get_feature, _set_feature)


  _pyangbind_elements = {'feature': feature, }


class yc_coordinate_normalBehaviour__normalClusterDescription_normalClusters_centroids_coordinate(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module normalBehaviour - based on the path /normalClusterDescription/normalClusters/centroids/coordinate. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__name','__value',)

  _yang_name = 'coordinate'
  _rest_name = 'coordinate'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="value", rest_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'normalClusterDescription', u'normalClusters', u'centroids', u'coordinate']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'normalClusterDescription', u'normalClusters', u'centroids', u'coordinate']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /normalClusterDescription/normalClusters/centroids/coordinate/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /normalClusterDescription/normalClusters/centroids/coordinate/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /normalClusterDescription/normalClusters/centroids/coordinate/value (decimal64)
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /normalClusterDescription/normalClusters/centroids/coordinate/value (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="value", rest_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="value", rest_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=7), is_leaf=True, yang_name="value", rest_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='decimal64', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = {'name': name, 'value': value, }


class yc_centroids_normalBehaviour__normalClusterDescription_normalClusters_centroids(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module normalBehaviour - based on the path /normalClusterDescription/normalClusters/centroids. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__name','__coordinate',)

  _yang_name = 'centroids'
  _rest_name = 'centroids'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__coordinate = YANGDynClass(base=YANGListType("name",yc_coordinate_normalBehaviour__normalClusterDescription_normalClusters_centroids_coordinate, yang_name="coordinate", rest_name="coordinate", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="coordinate", rest_name="coordinate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'normalClusterDescription', u'normalClusters', u'centroids']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'normalClusterDescription', u'normalClusters', u'centroids']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /normalClusterDescription/normalClusters/centroids/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /normalClusterDescription/normalClusters/centroids/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", rest_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)


  def _get_coordinate(self):
    """
    Getter method for coordinate, mapped from YANG variable /normalClusterDescription/normalClusters/centroids/coordinate (list)
    """
    return self.__coordinate
      
  def _set_coordinate(self, v, load=False):
    """
    Setter method for coordinate, mapped from YANG variable /normalClusterDescription/normalClusters/centroids/coordinate (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_coordinate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_coordinate() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_coordinate_normalBehaviour__normalClusterDescription_normalClusters_centroids_coordinate, yang_name="coordinate", rest_name="coordinate", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="coordinate", rest_name="coordinate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """coordinate must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_coordinate_normalBehaviour__normalClusterDescription_normalClusters_centroids_coordinate, yang_name="coordinate", rest_name="coordinate", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="coordinate", rest_name="coordinate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)""",
        })

    self.__coordinate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_coordinate(self):
    self.__coordinate = YANGDynClass(base=YANGListType("name",yc_coordinate_normalBehaviour__normalClusterDescription_normalClusters_centroids_coordinate, yang_name="coordinate", rest_name="coordinate", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="coordinate", rest_name="coordinate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  coordinate = __builtin__.property(_get_coordinate, _set_coordinate)


  _pyangbind_elements = {'name': name, 'coordinate': coordinate, }


class yc_normalClusters_normalBehaviour__normalClusterDescription_normalClusters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module normalBehaviour - based on the path /normalClusterDescription/normalClusters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__featureCombination','__centroids',)

  _yang_name = 'normalClusters'
  _rest_name = 'normalClusters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__featureCombination = YANGDynClass(base=unicode, is_leaf=True, yang_name="featureCombination", rest_name="featureCombination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)
    self.__centroids = YANGDynClass(base=YANGListType("name",yc_centroids_normalBehaviour__normalClusterDescription_normalClusters_centroids, yang_name="centroids", rest_name="centroids", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="centroids", rest_name="centroids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'normalClusterDescription', u'normalClusters']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'normalClusterDescription', u'normalClusters']

  def _get_featureCombination(self):
    """
    Getter method for featureCombination, mapped from YANG variable /normalClusterDescription/normalClusters/featureCombination (string)
    """
    return self.__featureCombination
      
  def _set_featureCombination(self, v, load=False):
    """
    Setter method for featureCombination, mapped from YANG variable /normalClusterDescription/normalClusters/featureCombination (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_featureCombination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_featureCombination() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="featureCombination", rest_name="featureCombination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """featureCombination must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="featureCombination", rest_name="featureCombination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)""",
        })

    self.__featureCombination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_featureCombination(self):
    self.__featureCombination = YANGDynClass(base=unicode, is_leaf=True, yang_name="featureCombination", rest_name="featureCombination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='string', is_config=True)


  def _get_centroids(self):
    """
    Getter method for centroids, mapped from YANG variable /normalClusterDescription/normalClusters/centroids (list)
    """
    return self.__centroids
      
  def _set_centroids(self, v, load=False):
    """
    Setter method for centroids, mapped from YANG variable /normalClusterDescription/normalClusters/centroids (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_centroids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_centroids() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_centroids_normalBehaviour__normalClusterDescription_normalClusters_centroids, yang_name="centroids", rest_name="centroids", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="centroids", rest_name="centroids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """centroids must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_centroids_normalBehaviour__normalClusterDescription_normalClusters_centroids, yang_name="centroids", rest_name="centroids", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="centroids", rest_name="centroids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)""",
        })

    self.__centroids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_centroids(self):
    self.__centroids = YANGDynClass(base=YANGListType("name",yc_centroids_normalBehaviour__normalClusterDescription_normalClusters_centroids, yang_name="centroids", rest_name="centroids", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="centroids", rest_name="centroids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)

  featureCombination = __builtin__.property(_get_featureCombination, _set_featureCombination)
  centroids = __builtin__.property(_get_centroids, _set_centroids)


  _pyangbind_elements = {'featureCombination': featureCombination, 'centroids': centroids, }


class yc_normalClusterDescription_normalBehaviour__normalClusterDescription(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module normalBehaviour - based on the path /normalClusterDescription. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__normalClusters',)

  _yang_name = 'normalClusterDescription'
  _rest_name = 'normalClusterDescription'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__normalClusters = YANGDynClass(base=YANGListType("featureCombination",yc_normalClusters_normalBehaviour__normalClusterDescription_normalClusters, yang_name="normalClusters", rest_name="normalClusters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='featureCombination', extensions=None), is_container='list', yang_name="normalClusters", rest_name="normalClusters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'normalClusterDescription']

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return [u'normalClusterDescription']

  def _get_normalClusters(self):
    """
    Getter method for normalClusters, mapped from YANG variable /normalClusterDescription/normalClusters (list)
    """
    return self.__normalClusters
      
  def _set_normalClusters(self, v, load=False):
    """
    Setter method for normalClusters, mapped from YANG variable /normalClusterDescription/normalClusters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_normalClusters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_normalClusters() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("featureCombination",yc_normalClusters_normalBehaviour__normalClusterDescription_normalClusters, yang_name="normalClusters", rest_name="normalClusters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='featureCombination', extensions=None), is_container='list', yang_name="normalClusters", rest_name="normalClusters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """normalClusters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("featureCombination",yc_normalClusters_normalBehaviour__normalClusterDescription_normalClusters, yang_name="normalClusters", rest_name="normalClusters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='featureCombination', extensions=None), is_container='list', yang_name="normalClusters", rest_name="normalClusters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)""",
        })

    self.__normalClusters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_normalClusters(self):
    self.__normalClusters = YANGDynClass(base=YANGListType("featureCombination",yc_normalClusters_normalBehaviour__normalClusterDescription_normalClusters, yang_name="normalClusters", rest_name="normalClusters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='featureCombination', extensions=None), is_container='list', yang_name="normalClusters", rest_name="normalClusters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='list', is_config=True)

  normalClusters = __builtin__.property(_get_normalClusters, _set_normalClusters)


  _pyangbind_elements = {'normalClusters': normalClusters, }


class normalBehaviour(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module normalBehaviour - based on the path /normalBehaviour. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_rest_name', '_extmethods', '__features','__normalClusterDescription',)

  _yang_name = 'normalBehaviour'
  _rest_name = ''

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__features = YANGDynClass(base=yc_features_normalBehaviour__features, is_container='container', presence=False, yang_name="features", rest_name="features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='container', is_config=True)
    self.__normalClusterDescription = YANGDynClass(base=yc_normalClusterDescription_normalBehaviour__normalClusterDescription, is_container='container', presence=False, yang_name="normalClusterDescription", rest_name="normalClusterDescription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _rest_path(self):
    if hasattr(self, "_parent"):
      if self._rest_name:
        return self._parent._rest_path()+[self._rest_name]
      else:
        return self._parent._rest_path()
    else:
      return []

  def _get_features(self):
    """
    Getter method for features, mapped from YANG variable /features (container)
    """
    return self.__features
      
  def _set_features(self, v, load=False):
    """
    Setter method for features, mapped from YANG variable /features (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_features is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_features() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_features_normalBehaviour__features, is_container='container', presence=False, yang_name="features", rest_name="features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """features must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_features_normalBehaviour__features, is_container='container', presence=False, yang_name="features", rest_name="features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='container', is_config=True)""",
        })

    self.__features = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_features(self):
    self.__features = YANGDynClass(base=yc_features_normalBehaviour__features, is_container='container', presence=False, yang_name="features", rest_name="features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='container', is_config=True)


  def _get_normalClusterDescription(self):
    """
    Getter method for normalClusterDescription, mapped from YANG variable /normalClusterDescription (container)
    """
    return self.__normalClusterDescription
      
  def _set_normalClusterDescription(self, v, load=False):
    """
    Setter method for normalClusterDescription, mapped from YANG variable /normalClusterDescription (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_normalClusterDescription is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_normalClusterDescription() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_normalClusterDescription_normalBehaviour__normalClusterDescription, is_container='container', presence=False, yang_name="normalClusterDescription", rest_name="normalClusterDescription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """normalClusterDescription must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_normalClusterDescription_normalBehaviour__normalClusterDescription, is_container='container', presence=False, yang_name="normalClusterDescription", rest_name="normalClusterDescription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='container', is_config=True)""",
        })

    self.__normalClusterDescription = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_normalClusterDescription(self):
    self.__normalClusterDescription = YANGDynClass(base=yc_normalClusterDescription_normalBehaviour__normalClusterDescription, is_container='container', presence=False, yang_name="normalClusterDescription", rest_name="normalClusterDescription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://www.ncsu.edu/', defining_module='normalBehaviour', yang_type='container', is_config=True)

  features = __builtin__.property(_get_features, _set_features)
  normalClusterDescription = __builtin__.property(_get_normalClusterDescription, _set_normalClusterDescription)


  _pyangbind_elements = {'features': features, 'normalClusterDescription': normalClusterDescription, }


